{
    "task.allowAutomaticTasks": "on",
    "webgl-glsl-editor.codeInjection": true,
    "webgl-glsl-editor.codeInjectionSource": [
        "#version 300 es",
        "precision highp float;",
        "precision highp int;",
        "precision highp usampler2D;",
        "// shared/global stuff\r",
        "#define PASS_COLOR 0\r",
        "#define PASS_PICK 1\r",
        "#define PASS_PRE 2\r",
        "\r",
        "#ifndef PASS\r",
        "#define PASS PASS_COLOR // avoid red squigglies in editor\r",
        "#endif\r",
        "\r",
        "struct CameraUniforms {\r",
        "    highp mat4 clipViewMatrix;\r",
        "    highp mat4 viewClipMatrix;\r",
        "    highp mat4 localViewMatrix;\r",
        "    highp mat4 viewLocalMatrix;\r",
        "    highp mat3 localViewMatrixNormal;\r",
        "    highp mat3 viewLocalMatrixNormal;\r",
        "    highp mat3 localBackgroundMatrixNormal;\r",
        "    highp vec2 viewSize;\r",
        "    highp float near; // near clipping plane distance\r",
        "};\r",
        "struct IBLTextures {\r",
        "    mediump samplerCube specular;\r",
        "    mediump samplerCube diffuse;\r",
        "};\r",
        "\r",
        "// background\r",
        "struct BackgroundVaryings {\r",
        "    mediump vec3 dir;\r",
        "};\r",
        "struct BackgroundUniforms {\r",
        "    lowp float envBlurNormalized;\r",
        "    lowp int mipCount;\r",
        "};\r",
        "struct BackgroundTextures {\r",
        "    lowp samplerCube skybox;\r",
        "    IBLTextures ibl;\r",
        "};\r",
        "\r",
        "// clipping\r",
        "const lowp uint undefinedIndex = 7U;\r",
        "const highp uint clippingId = 0xfffffff0U;\r",
        "const lowp uint clippingModeIntersection = 0U;\r",
        "const lowp uint clippingModeUnion = 1U;\r",
        "const lowp float highLightsTextureRows = 8.;\r",
        "\r",
        "struct ClippingVaryings {\r",
        "    mediump vec3 dirVS;\r",
        "};\r",
        "struct ClippingUniforms {\r",
        "    highp vec4 planes[6];\r",
        "    lowp uint numPlanes;\r",
        "    lowp uint mode; // 0 = intersection, 1 = union\r",
        "};\r",
        "struct ClippingColors {\r",
        "    mediump vec4 colors[6];\r",
        "};\r",
        "bool clip(highp vec3 point, ClippingUniforms clipping) {\r",
        "    float s = clipping.mode == clippingModeIntersection ? -1. : 1.;\r",
        "    bool inside = clipping.mode == clippingModeIntersection ? clipping.numPlanes > 0U : true;\r",
        "    for(uint i = 0U; i < clipping.numPlanes; i++) {\r",
        "        inside = inside && dot(vec4(point, 1), clipping.planes[i]) * s < 0.;\r",
        "    }\r",
        "    return clipping.mode == clippingModeIntersection ? inside : !inside;\r",
        "}\r",
        "\r",
        "// outlines\r",
        "struct OutlineUniforms {\r",
        "    highp mat4 localPlaneMatrix;\r",
        "    highp mat4 planeLocalMatrix;\r",
        "    mediump vec3 lineColor;\r",
        "    lowp int planeIndex;\r",
        "    mediump vec3 pointColor;\r",
        "    mediump float linearSize;\r",
        "    mediump float minPixelSize;\r",
        "    mediump float maxPixelSize;\r",
        "    mediump float pointScale;\r",
        "    highp uint pointObjectIdBase;\r",
        "};\r",
        "\r",
        "bool clipOutlines(highp vec3 point, ClippingUniforms clipping) {\r",
        "    float s = clipping.mode == clippingModeIntersection ? -1. : 1.;\r",
        "    bool inside = clipping.mode == clippingModeIntersection ? clipping.numPlanes > 0U : true;\r",
        "    for(uint i = 0U; i < clipping.numPlanes; i++) {\r",
        "        inside = inside && dot(vec4(point, 1), clipping.planes[i]) * s < 0.;\r",
        "    }\r",
        "    return !inside;\r",
        "}\r",
        "\r",
        "// cube\r",
        "const uint cubeId = 0xfffffff8U;\r",
        "struct CubeVaryings {\r",
        "    highp vec3 posVS;\r",
        "    mediump vec3 normal;\r",
        "    mediump vec3 color;\r",
        "};\r",
        "struct CubeUniforms {\r",
        "    highp mat4 modelLocalMatrix;\r",
        "};\r",
        "\r",
        "// grid\r",
        "struct GridVaryings {\r",
        "    highp vec2 posOS;\r",
        "    highp vec3 posLS;\r",
        "};\r",
        "struct GridUniforms {\r",
        "    // below coords are in local space\r",
        "    highp vec3 origin;\r",
        "    mediump vec3 axisX;\r",
        "    mediump vec3 axisY;\r",
        "    highp float size1;\r",
        "    highp float size2;\r",
        "    mediump vec3 color1;\r",
        "    mediump vec3 color2;\r",
        "    highp float distance;\r",
        "};\r",
        "\r",
        "struct ToonOutlineUniforms {\r",
        "    mediump vec3 color;\r",
        "    uint outlineObjects;\r",
        "};\r",
        "\r",
        "// dynamic geometry\r",
        "const vec3 ambientLight = vec3(0);\r",
        "struct DynamicVaryings {\r",
        "    mediump vec4 color0;\r",
        "    highp vec2 texCoord0;\r",
        "    highp vec2 texCoord1;\r",
        "    highp vec3 positionVS;\r",
        "    highp float linearDepth;\r",
        "    mediump mat3 tbn; // in world space\r",
        "    highp vec3 toCamera; // in world space (camera - position)\r",
        "};\r",
        "struct DynamicVaryingsFlat {\r",
        "#if defined (ADRENO600)\r",
        "    mediump uint objectId_low;\r",
        "    mediump uint objectId_high;\r",
        "#else\r",
        "    highp uint objectId;\r",
        "#endif\r",
        "};\r",
        "struct MaterialUniforms {\r",
        "    mediump vec4 baseColorFactor;\r",
        "    mediump vec3 emissiveFactor;\r",
        "    mediump float roughnessFactor;\r",
        "    mediump float metallicFactor;\r",
        "    mediump float normalScale;\r",
        "    mediump float occlusionStrength;\r",
        "    mediump float alphaCutoff;\r",
        "    lowp int baseColorUVSet;\r",
        "    lowp int metallicRoughnessUVSet;\r",
        "    lowp int normalUVSet;\r",
        "    lowp int occlusionUVSet;\r",
        "    lowp int emissiveUVSet;\r",
        "    lowp uint radianceMipCount;\r",
        "};\r",
        "struct ObjectUniforms {\r",
        "    highp mat4 worldLocalMatrix;\r",
        "    highp uint baseObjectId;\r",
        "};\r",
        "struct DynamicTextures {\r",
        "    mediump sampler2D lut_ggx;\r",
        "    IBLTextures ibl;\r",
        "    lowp sampler2D base_color;\r",
        "    mediump sampler2D metallic_roughness;\r",
        "    mediump sampler2D normal;\r",
        "    mediump sampler2D emissive;\r",
        "    mediump sampler2D occlusion;\r",
        "};\r",
        "\r",
        "// octree\r",
        "#define MODE_TRIANGLES 0\r",
        "#define MODE_POINTS 1\r",
        "#define MODE_TERRAIN 2\r",
        "\r",
        "#ifndef MODE\r",
        "#define MODE MODE_TRIANGLES // avoid red squigglies in editor\r",
        "#endif\r",
        "\r",
        "#ifndef NUM_CLIPPING_PLANES\r",
        "#define NUM_CLIPPING_PLANES 0 // avoid red squigglies in editor\r",
        "#endif\r",
        "\r",
        "const uint maxHighlights = 256U;\r",
        "struct OctreeVaryings {\r",
        "    highp vec3 positionLS; // world/local space\r",
        "    mediump vec3 normalLS; // world/local space\r",
        "    highp vec3 positionVS; // view space\r",
        "    mediump vec3 normalVS; // view space\r",
        "    highp vec3 toCamera; // world/local space\r",
        "    highp vec2 texCoord0;\r",
        "    highp vec2 screenPos;\r",
        "    mediump float radius;\r",
        "    mediump float pointFactor;\r",
        "    mediump float elevation;\r",
        "};\r",
        "struct OctreeVaryingsFlat {\r",
        "    lowp vec4 color;\r",
        "#if defined (ADRENO600)\r",
        "    mediump uint objectId_low;\r",
        "    mediump uint objectId_high;\r",
        "#else\r",
        "    highp uint objectId;\r",
        "#endif\r",
        "    lowp uint highlight;\r",
        "};\r",
        "struct SceneUniforms {\r",
        "    bool applyDefaultHighlight;\r",
        "    lowp int defaultPointGradientKind;\r",
        "    lowp float iblMipCount;\r",
        "    // point cloud\r",
        "    mediump float pixelSize;\r",
        "    mediump float maxPixelSize;\r",
        "    mediump float metricSize;\r",
        "    mediump float toleranceFactor;\r",
        "    bool useProjectedPosition;\r",
        "    lowp float pickOpacityThreshold;\r",
        "    mediump vec2 factorRange[8];\r",
        "    lowp vec4 undefinedPointColor;\r",
        "};\r",
        "struct NodeUniforms {\r",
        "    highp mat4 modelLocalMatrix;\r",
        "    mediump float tolerance;\r",
        "    lowp vec4 debugColor;\r",
        "    // min,max are in local space\r",
        "    highp vec3 min;\r",
        "    highp vec3 max;\r",
        "};\r",
        "const struct OctreeTextures {\r",
        "    IBLTextures ibl;\r",
        "    lowp sampler2D materials;\r",
        "    mediump sampler2D highlights;\r",
        "    mediump sampler2D gradients;\r",
        "    mediump sampler2D lut_ggx;\r",
        "    mediump sampler2DArray base_color;\r",
        "    mediump sampler2DArray nor; // normal, occlusion and roughness\r",
        "};\r",
        "const struct NodeTextures {\r",
        "    lowp sampler2D unlit_color;\r",
        "};\r",
        "\r",
        "// watermark\r",
        "struct WatermarkVaryings {\r",
        "    mediump float elevation;\r",
        "};\r",
        "struct WatermarkUniforms {\r",
        "    highp mat4 modelClipMatrix;\r",
        "    mediump vec4 color;\r",
        "};\r",
        "\r",
        "// tonemapping\r",
        "const mediump float tonemapMaxDeviation = 1.;\r",
        "const lowp uint tonemapModeColor = 0U;\r",
        "const lowp uint tonemapModeNormal = 1U;\r",
        "const lowp uint tonemapModeDepth = 2U;\r",
        "const lowp uint tonemapModeObjectId = 3U;\r",
        "const lowp uint tonemapModeDeviation = 4U;\r",
        "const lowp uint tonemapModeZbuffer = 5U;\r",
        "struct TonemappingVaryings {\r",
        "    highp vec2 uv;\r",
        "};\r",
        "struct TonemappingUniforms {\r",
        "    mediump float exposure;\r",
        "    lowp uint mode;\r",
        "    highp float maxLinearDepth;\r",
        "};\r",
        "struct TonemappingTextures {\r",
        "    mediump sampler2D color;\r",
        "    highp usampler2D pick;\r",
        "    highp sampler2D zbuffer;\r",
        "};\r",
        "\r",
        "// dither transparency\r",
        "const mediump mat4 ditherThresholds = mat4(0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0, 12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0, 3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0, 15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\r",
        "mediump float dither(highp vec2 xy) {\r",
        "    lowp int x = int(xy.x) & 3;\r",
        "    lowp int y = int(xy.y) & 3;\r",
        "    return ditherThresholds[y][x];\r",
        "}\r",
        "\r",
        "// sRGB\r",
        "const mediump float GAMMA = 2.2;\r",
        "const mediump float INV_GAMMA = 1.0 / GAMMA;\r",
        "// linear to sRGB approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "mediump vec3 linearTosRGB(mediump vec3 color) {\r",
        "    return pow(color, vec3(INV_GAMMA));\r",
        "}\r",
        "// sRGB to linear approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "mediump vec3 sRGBToLinear(mediump vec3 srgbIn) {\r",
        "    return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\r",
        "}\r",
        "\r",
        "mediump float toLinear(mediump float f) {\r",
        "    if(f <= 0.0404482362771082) {\r",
        "        return f / 12.92;\r",
        "    }\r",
        "    return pow(((f + 0.055) / 1.055), GAMMA);\r",
        "}\r",
        "\r",
        "// sRGB to linear approximation (http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html)\r",
        "mediump vec3 sRGBToLinearComplex(mediump vec3 srgbIn) {\r",
        "    return vec3(toLinear(srgbIn.r), toLinear(srgbIn.g), toLinear(srgbIn.b));\r",
        "}\r",
        "\r",
        "vec3 linearTosRGBComplex(vec3 color) {\r",
        "    vec3 srgb;\r",
        "    for(int i = 0; i < 3; ++i) {\r",
        "        if(color[i] <= 0.0031308) {\r",
        "            srgb[i] = 12.92 * color[i];\r",
        "        } else {\r",
        "            srgb[i] = 1.055 * pow(color[i], INV_GAMMA) - 0.055;\r",
        "        }\r",
        "    }\r",
        "    return srgb;\r",
        "}\r",
        "\r",
        "// gradients\r",
        "const lowp float numGradients = 8.;\r",
        "const lowp int gradientKindNone = -1;\r",
        "const lowp int gradientKindElevation = 0;\r",
        "const lowp int gradientKindClassification = 1;\r",
        "const lowp int gradientKindDeviations0 = 2;\r",
        "const lowp int gradientKindIntensity = 8; //Intensity does not use gradient, uses grayscale\r",
        "\r",
        "mediump vec4 getGradientColor(mediump sampler2D gradientTexture, highp float position, lowp int gradientKind, highp vec2 range) {\r",
        "    mediump float v = (float)gradientKind / numGradients + .5 / numGradients;\r",
        "    mediump float u = (range[0] >= range[1]) ? 0. : (position - range[0]) / (range[1] - range[0]);\r",
        "    return texture(gradientTexture, vec2(u, v));\r",
        "}\r",
        "\r",
        "// packing\r",
        "\r",
        "// we use octrahedral packing of normals to map 3 components down to 2: https://jcgt.org/published/0003/02/01/\r",
        "mediump vec2 signNotZero(mediump vec2 v) { // returns ±1\r",
        "    return vec2((v.x >= 0.) ? +1. : -1., (v.y >= 0.) ? +1. : -1.);\r",
        "}\r",
        "\r",
        "mediump vec2 float32x3_to_oct(mediump vec3 v) { // assume normalized input. Output is on [-1, 1] for each component.\r",
        "    // project the sphere onto the octahedron, and then onto the xy plane\r",
        "    mediump vec2 p = v.xy * (1. / (abs(v.x) + abs(v.y) + abs(v.z)));\r",
        "    // reflect the folds of the lower hemisphere over the diagonals\r",
        "    return (v.z <= 0.) ? ((1. - abs(p.yx)) * signNotZero(p)) : p;\r",
        "}\r",
        "\r",
        "mediump vec3 oct_to_float32x3(mediump vec2 e) {\r",
        "    mediump vec3 v = vec3(e.xy, 1. - abs(e.x) - abs(e.y));\r",
        "    if(v.z < 0.)\r",
        "        v.xy = (1. - abs(v.yx)) * signNotZero(v.xy);\r",
        "    return normalize(v);\r",
        "}\r",
        "\r",
        "highp uvec2 packNormalAndDeviation(mediump vec3 normal, mediump float deviation) {\r",
        "    return uvec2(packHalf2x16(normal.xy), packHalf2x16(vec2(normal.z, deviation)));\r",
        "}\r",
        "\r",
        "highp uvec2 packNormal(mediump vec3 normal) {\r",
        "    return packNormalAndDeviation(normal, 0.);\r",
        "}\r",
        "\r",
        "mediump vec4 unpackNormalAndDeviation(highp uvec2 normalAndDeviation) {\r",
        "    return vec4(unpackHalf2x16(normalAndDeviation[0]), unpackHalf2x16(normalAndDeviation[1]));\r",
        "}\r",
        "\r",
        "highp uint combineMediumP(highp uint high, highp uint low) {\r",
        "    return (high << 16u) | (low & 0xffffu);\r",
        "}\r",
        ""
    ],
    "typescript.tsdk": "node_modules\\typescript\\lib"
}